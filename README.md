# Code-Squard
과제 찾아서 풀어보기


## Level 2
### 코드스쿼드의 레벨 2 문제를 해결해보았다.
https://deadwhale.notion.site/Level2-68cf30ba733f444ba5b9cb5e306c5b3f

>10/13
- 과제에서 요구하는 모든 기능을 구현해 보았다.
>10/16
- 기능을 인터페이스와 구현체로 분리
>10/17
- 오류를 해결하고 구현 완료
- 코드의 길이 / 뎁스 확인 필요

-----
Computer  - 컴퓨터가 수행해야하는 기능의 인터페이스
  -    int[] makeAnswer();
    - 정답을 생성하는 메소드
  -    Map<String, Integer> checking(int[] answer , int[]swing);
    - 입력받은 배열과 답을 비교해 결과를 반환하는 메서드
  -    boolean chkResult(Map<String,Integer> map);
    - 결과를 출력하고 반복할지 끈낼지 반환하는 메서드
    
User    - 사용자가 해야하는 동작의 인터페이스
  -   int[] inputNumbers() throws InputMismatchException;
    - 입력받은 값을 전달하는 메서드
  -   int[] strToArray(String n);
    - 파라미터로 전달받은 문자열을 배열로 반환하는 메서드
    
    
공통 사항 
-  입력시 정수 아닐 경우네는 Pasing 시 발생하는 NumberFormetException으로 던져버린다
-  입력 값의 길이가 3이 아닐 경우에 에러 생성.  에러 의미상 inputMisMatch으로 구현했다.

-----

## Level 3
### 코드스쿼드의 레벨 3 문제를 해결해보았다.
- 기능 구현 보다 볼링 점수 계산 방식을 공부하는게 더 어려웠다.
### 볼링게임 하는법

- 한번에 두번의 기회
- 핀 하나당 1점 ( 최대 10점 ⏩ 스트라이크)

### 스페어 ( / )
- 두개의 공 이용해 10개 전부 쓰러트릴 경우 (2번의 기회)
  - 다음번 첫번째 공으로 넘어트린 점수만큼 보너스 
    - 9|/  ⏩ 7|?  
      - ⏩ 9+1 + 보너스 (7점) ⏩ 17점 
    - 5|5  ⏩ 1|?  
      - ⏩ 5+5 + 보너스 (1점) ⏩ 11점

### 스트라이크 ( X )
- 한개의 공을 이용해 10개 전부 쓰러트릴 경우 (1번의 기회)
  - 다음번 두개의 공으로 넘어트린 점수만큼 보너스
    - x | - ⏩  5 | 2  
      - 10 ➕ 보너스(5+2) ➡ 17점
    - x | - ⏩  5 | /  
      - 10 ➕ 보너스 (5+5) ➡ 20점
    
    - 만약 연속해 스트라이크를 성공할 경우
    - 무조건 다음 2번의 기회 동안 넘어트린 개수이기 때문에 다음 공까지 넘어간다
    - x  | - ⏩  x | -  ⏩  5 | -
      - 10 ➕ 보너스(10) ➕ 보너스(5) ➡ 25점
    

### 10 Frame
- 마지막 기회는 약간의 차이점이 발생한다.
- 만약 2번의 기회 동안 스페어 혹은 스트라이크를 성공할 경우 추가적으로 한번의 기회를 더 얻는다.




플레이어 이름은(3 english letters)?: PJS

```
플레이어 이름은(3 english letters)?: PJS
| NAME |  01  |  02  |  03  |  04  |  05  |  06  |  07  |  08  |  09  |  10  |
|  PJS |      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |

PJS's turn : 10
| NAME |  01  |  02  |  03  |  04  |  05  |  06  |  07  |  08  |  09  |  10  |
|  PJS |  X   |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |

PJS's turn : 8
| NAME |  01  |  02  |  03  |  04  |  05  |  06  |  07  |  08  |  09  |  10  |
|  PJS |  X   |  8   |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |

PJS's turn : 2
| NAME |  01  |  02  |  03  |  04  |  05  |  06  |  07  |  08  |  09  |  10  |
|  PJS |  X   |  8|/ |      |      |      |      |      |      |      |      |
|      |  20  |      |      |      |      |      |      |      |      |      |

PJS's turn : 7
| NAME |  01  |  02  |  03  |  04  |  05  |  06  |  07  |  08  |  09  |  10  |
|  PJS |  X   |  8|/ |  7   |      |      |      |      |      |      |      |
|      |  20  |  37  |      |      |      |      |      |      |      |      |

PJS's turn : 0
| NAME |  01  |  02  |  03  |  04  |  05  |  06  |  07  |  08  |  09  |  10  |
|  PJS |  X   |  8|/ |  7|- |      |      |      |      |      |      |      |
|      |  20  |  37  |  44  |      |      |      |      |      |      |      |

PJS's turn : 10
```

#### 프로그래밍 제약 사항
* 객체 지향 설계 기반 개발이 가능하도록 구현한다.
* 상속을 사용해 구현해야 한다. 예를 들어 1 ~ 9 프레임과 10 프레임의 동작 방식이 다른데 이 부분을 상속을 통해 해결해 본다.
* 배열 대신 java의 collection(List, Map 등)을 사용해 구현해야 한다.
* 중요한 로직에 대한 소스 코드는 junit 기반의 단위 테스트가 존재해야 한다.
* indent(인덴트, 들여쓰기) depth를 2단계에서 1단계로 줄여라.
    * depth의 경우 if문을 사용하는 경우 1단계의 depth가 증가한다. if문 안에 while문을 사용한다면 depth가 2단계가 된다.
* else를 사용하지 마라.
* 메소드의 크기가 최대 10라인을 넘지 않도록 구현한다.
    * method가 한 가지 일만 하도록 최대한 작게 만들어라.


----
### 요구사항

#### Gamer
- 이름을 입력받아야 한다.
- 매턴 마다 2번의 점수를 입력받아야한다
  - 0~10 사이의 수 
  - 10일 경우 스트라이크
#### Frame 
1 - 9
- 입력 받은 점수를 이전 점수에 누적한다.
- 스페어일 경우 다음 값 하나를 가져와 누적해야 한다.
- 스트라이크일 경우 다음 1이상의 값 두개를 누적한다
10 
- 10번 프레임에서 스트라이크 OR 스페어 시 한번의 기회를 더 부여받는다.
----